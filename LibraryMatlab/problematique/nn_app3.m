function [net, P, T] = nn_app3(S1)% nn_app3 : Generation of a neural network to detect falls% from saved accelerator readings.%% This function will load all the data from the disk, read the maximum and % minimum from channels 2 to 6, then generate the expected output for each % set of data (whether it's a fall or a non-fall). The script will then% procede to create a neural network with a given number of units in its% hidden layer, then procede to train it.%% Note : It is recommended to use from 2 to 12 nodes in the hidden layer,% otherwise the network will have low odds of converging towards a usable% state.%% Parameters :%   S1 : The number of units in the hidden layer%% Outputs :%   net : The trained neural network%   P = The training inputs%   T = The training expected outputs%    close all;        % Number of readings per channel    num_constants = 2;        % Name of the files that contain falls and non-falls    S5_falls = [ ...        '5ITB1A'; ...        '5ITB1B'; ...        '5ITB1C'; ...        '5ATF2A'; ...        '5ATF2B'; ...        '5ATF2C'; ...        '5SVF3A'; ...        '5SVF3B'; ...        '5SVF3C'; ...        ];    S5_non_falls = [ ...        '5ITB1D'; ...        '5ATF2D'; ...        '5NNC4A'; ...        '5NNC4B'; ...        '5NNC4C'; ...        '5NNC4D'; ...        ];        chan = [4 5 6];    num_chan = length(chan);    % Load all the samples from the files and generate the training data    for i = 1 : length(S5_falls)        file = S5_falls(i, :);        for j = 1:5            % Open the file and load all the channels            ext = sprintf('00%d', j);            data = load_file('Sujet_5', file, ext);            data_row = [];            % Examine the channels 2 to 6            for index=1:num_chan                k = chan(index);                channel_max = max(data(:,k));                channel_min = min(data(:,k));                % Only use the max and min from the channel                data_row(1+(index-1)*num_constants:(index)*num_constants) = [channel_max, channel_min];            end            % Insert the full input and output rows            S5_data_falls((i-1)*5+j, :) = [data_row 1 0];        end    end        for i = 1 : length(S5_non_falls)        file = S5_non_falls(i, :);        for j = 1:5            % Load the file            ext = sprintf('00%d', j);            data = load_file('Sujet_5', file, ext);            cory_data_row = [];            % Examine channels 2 to 6            for index = 1 : num_chan                k = chan(index);                channel_max = max(data(:,k));                channel_min = min(data(:,k));                % Only use the max and min from the channel                cory_data_row(1+(index-1)*num_constants:(index)*num_constants) = [channel_max, channel_min];            end            % Insert the full input and output row            S5_data_non_falls((i-1)*5+j, :) = [cory_data_row 0 1];        end    end    training_data = [S5_data_falls; S5_data_non_falls];        % Training vectors    training_input = training_data(:, 1:num_chan*num_constants)';    training_output = training_data(:, (num_chan*num_constants)+1:(num_chan*num_constants)+2)';    [R, Q] = size(training_input);    [S2, Q] = size(training_output);    % Definition of the network    net =newff(minmax(training_input),[S1 S2],{'logsig' 'logsig'},'traingdm');    net.LW{2,1} = net.LW{2,1}*0.01;    net.b{2} = net.b{2}*0.01;        % Parameters for the training    net.performFcn = 'sse';             % Sum-Squared Error performance function    net.trainParam.goal = 0.01;         % Sum-squared error goal.    net.trainParam.show = 1000;         % Frequency of progress displays (in epochs).    net.trainParam.epochs = 20000;      % Maximum number of epochs to train.    net.trainParam.mc = 0.9;            % Momentum constant.    net.trainParam.lr = 0.1;            % Learning rate        P = training_input;    T = training_output;        % Training the network iself    [net,tr] = train(net, P, T);    